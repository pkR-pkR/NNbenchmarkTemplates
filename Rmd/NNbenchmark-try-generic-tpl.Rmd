---
title: "NNbenchmark | AMORE"
author: "Akshaj Verma, Christophe Dutang"
output:
    html_document:
        toc: true
        toc_float: true
        df_print: paged
        number_sections: true
        theme: darkly
        highlight: tango
---


```{r message=FALSE, warning=FALSE}
library(NNbenchmark)
library(AMORE)

library(stringr)
library(dplyr)
library(kableExtra)
```

## Set Environment
```{r}
options(scipen = 9999)
options("digits.secs" = 2)
timer  <- createTimer(verbose = FALSE)
```

## Datasets to Test

```{r}
NNdataSummary(NNdatasets)
str(NNdatasets)
```

## NN Train Function
```{r}
hyperParams.AMORE <- function(optim_method) {
    
    if (!is.element(optim_method, c("ADAPTgd", "ADAPTgdwm", "BATCHgd", "BATCHgdwm"))) stop("Invalid Parameters.")
    if (optim_method == "ADAPTgd") {iter <- 3500; lr <- 0.01; momentum <- 0; hidden_activation <- "tansig"} 
    if (optim_method == "ADAPTgdwm") {iter <- 4000; lr <- 0.009; momentum <- 0.8; hidden_activation <- "sigmoid"} 
    if (optim_method == "BATCHgd") {iter <- 7500; lr <- 0.01; momentum <- 0; hidden_activation <- "tansig"}
    if (optim_method == "BATCHgdwm") {iter <- 9000; lr <- 0.008; momentum <- 0.7; hidden_activation <- "tansig"}
    
    params <- paste0("method=", optim_method, "_lr=", lr, "_iter=", iter, "_momentum=", momentum, "_hidden_activation=", hidden_activation)
    
    out <- list(iter = iter, lr = lr, params = params, momentum = momentum, hidden_activation = hidden_activation)
    
    return (out)
}



NNtrain.AMORE <- function(x, y, hidden_neur, optim_method, hyperParams) {
    
    hyper_params <- hyperParams(optim_method)
    
    iter <- hyper_params$iter
    lr <- hyper_params$lr
    momentum <- hyper_params$momentum
    hidden_activation <- hyper_params$hidden_activation
    
    net_structure <- AMORE::newff(n.neurons = c(ncol(x), hidden_neur, 1), 
                                  learning.rate.global = lr, 
                                  error.criterium = "LMS", 
                                  hidden.layer = hidden_activation, 
                                  method = optim_method,
                                  momentum.global = momentum)
    
    NNreg <- AMORE::train(net = net_structure, 
                          P = x, T = y, 
                          error.criterium = "LMS", 
                          report = FALSE, 
                          n.shows = iter, 
                          show.step = 1)
    
    return (NNreg)
}
```

## Small try
```{r}
dset <- 1
ds     <- NNdatasets[[dset]]$ds
    Z      <- NNdatasets[[dset]]$Z
    neur   <- NNdatasets[[dset]]$neur
    nparNN <- NNdatasets[[dset]]$nparNN
    fmlaNN <- NNdatasets[[dset]]$fmlaNN

    AMORE.method <- c("ADAPTgd", "ADAPTgdwm", "BATCHgd", "BATCHgdwm")
    
ZZ     <- prepareZZ(Z, xdmv = "d", ydmv = "v", zdm = "d", scale = TRUE)    
str(ZZ)
resfit <- do.call("NNtrain.AMORE", list(ZZ$x, ZZ$y, neur, AMORE.method[1],  hyperParams.AMORE))
str(resfit)

NNpredict.AMORE <- function(object, x)
    AMORE::sim.MLPnet(object$net, x)    

respred <- ZZ$ym0 + ZZ$ysd0 * do.call("NNpredict.AMORE", list(resfit, ZZ$x))
str(respred)

c(RMSE = NNbenchmark::funRMSE(respred, ZZ$y0), MAE= NNbenchmark::funMAE(respred, ZZ$y0))
            
```


## generic call

```{r}

NNsummary <- function(pred, obsy, time)
    c(RMSE = NNbenchmark::funRMSE(pred, obsy), MAE= NNbenchmark::funMAE(pred, obsy), time=time)

train_and_predict_1mth_1data <- function(dset, method, trainFUN, hyperparamFUN, predictFUN, 
                                         summaryFUN, nrep=5, 
                                         pkgname, pkgfun, rdafile=FALSE, odir="~/", echo=FALSE)
{
    method <- method[1]
    
    timer  <- createTimer(verbose = FALSE)
    
    ds     <- NNdatasets[[dset]]$ds
    Z      <- NNdatasets[[dset]]$Z
    neur   <- NNdatasets[[dset]]$neur
    nparNN <- NNdatasets[[dset]]$nparNN
    fmlaNN <- NNdatasets[[dset]]$fmlaNN
    
    descr <- paste0(ds, "_", pkgname, "::", pkgfun, "_", method)
        
    ZZ     <- prepareZZ(Z, xdmv = "d", ydmv = "v", zdm = "d", scale = TRUE)    
    
    #init
    timer$start(descr)
    resfit <- do.call(trainFUN, list(ZZ$x, ZZ$y, neur, method[1],  hyperparamFUN))
    respred <- ZZ$ym0 + ZZ$ysd0 * do.call(predictFUN, list(resfit, ZZ$x))
    timer$stop(descr, RMSE = NA, MAE = NA, params = NA, printmsg = FALSE)
    resummary <- summaryFUN(respred, ZZ$y0, round(getTimer(timer)[ ,4], 5))
    
    if(echo)
        cat("i", 1, "summary statistics", resummary[1:2], "time", resummary[3], "\n")
    if(nrep > 1)
    {
        for(i in 2:nrep)
        {
            timer$start(descr)
            tempfit <- do.call(trainFUN, list(ZZ$x, ZZ$y, neur, method,  hyperparamFUN))
            temppred <- ZZ$ym0 + ZZ$ysd0 * do.call(predictFUN, list(resfit, ZZ$x))   
            timer$stop(descr, RMSE = NA, MAE = NA, params = NA, printmsg = FALSE)
            tempsummary <- summaryFUN(temppred, ZZ$y0, round(getTimer(timer)[ ,4], 5))
        
            if(echo)
                cat("i", i, "summary statistics", tempsummary[1:2], "time", tempsummary[3], "\n")
            if(tempsummary["RMSE"] < resummary["RMSE"])
            {
                resfit <- tempfit
                respred <- temppred
                resummary <- tempsummary
            }
        }
    }
    
    if(rdafile)
    {
        descr <- paste0(ds, "_", pkgname, "_", pkgfun, "_", method)
        myfile <- paste0(odir, descr, ".RData")
        save(respred, resfit, resummary, file=myfile)
    }
    resummary
}

train_and_predict_1data <- function(dset, methodvect, trainFUN, hyperparamFUN, predictFUN, 
                                    summaryFUN, nrep=5, pkgname, pkgfun, rdafile, odir="~/", echo=FALSE)
{
    resallmethod <- sapply(1:length(methodvect), function(i)
            train_and_predict_1mth_1data(dset, methodvect[i], trainFUN, hyperparamFUN, predictFUN, 
                                         summaryFUN, nrep=nrep, 
                                         pkgname, pkgfun, rdafile, odir, echo))
    
    colnames(resallmethod) <- methodvect
    resallmethod
}

odir <- "~/Documents/recherche-enseignement/code/R/NNbenchmark-project/NNtempresult/"
AMORE.method <- c("ADAPTgd", "ADAPTgdwm", "BATCHgd", "BATCHgdwm")

res <- train_and_predict_1data(1, AMORE.method, "NNtrain.AMORE", hyperParams.AMORE, "NNpredict.AMORE", 
                               NNsummary, nrep=2, echo=TRUE,
                               pkgname="AMORE", pkgfun="newff", rdafile=TRUE, odir=odir)

f <- function(i)
    train_and_predict_1data(i, method, "NNtrain.AMORE", hyperParams.AMORE, "NNpredict.AMORE")


library(parallel)

cl <- parallel::makeCluster(2)
print(showConnections())
#put global environment and load packages
parallel::clusterEvalQ(cl, library(NNbenchmark))
parallel::clusterExport(cl, "NNdatasets")
parallel::clusterExport(cl, ls(1))
res <- try( t(parallel::parLapply(cl, 1:2, f)) )
parallel::stopCluster(cl)

```



## Main Loop
```{r fig.height=5, fig.width=14, message=FALSE, warning=FALSE}
for (dset in names(NNdatasets)) {

    ## =============================================
    ## EXTRACT INFORMATION FROM THE SELECTED DATASET
    ## =============================================
    ds     <- NNdatasets[[dset]]$ds
    Z      <- NNdatasets[[dset]]$Z
    neur   <- NNdatasets[[dset]]$neur
    nparNN <- NNdatasets[[dset]]$nparNN
    fmlaNN <- NNdatasets[[dset]]$fmlaNN
    donotremove  <- c("dset", "dsets", "ds", "Z", "neur", "TF", "nrep", "timer",
                      "donotremove", "donotremove2")
    donotremove2 <- c("dset", "dsets") 



    ## ===================================================
    ## SELECT THE FORMAT REQUIRED BY THE PACKAGE/ALGORITHM
    ## d = data.frame, m = matrix, v = vector/numeric
    ## ATTACH THE OBJECTS CREATED (x, y, Zxy, ... )
    ## ===================================================
    ZZ     <- prepareZZ(Z, xdmv = "d", ydmv = "v", zdm = "d", scale = TRUE)
    attach(ZZ)

    ## =============================================
    ## SELECT THE PACKAGE USED FOR TRAINING
    ## nrep => SELECT THE NUMBER OF INDEPENDANT RUNS
    ## iter => SELECT THE MAX NUMBER OF ITERATIONS
    ## TF   => PLOT THE RESULTS
    ## =============================================

    
    nrep   <- 10
    TF     <- TRUE 

    method <- c("ADAPTgd", "ADAPTgdwm", "BATCHgd", "BATCHgdwm")
        
    for (m in method) {
        
        descr  <- paste(dset, "AMORE::train", m, sep = "_")

        ## AUTO
        Ypred  <- list()
        Rmse   <- numeric(length = nrep)
        Mae    <- numeric(length = nrep)
    
        for(i in 1:nrep){
            event      <- paste0(descr, sprintf("_%.2d", i))
            timer$start(event)
            #### ADJUST THE FOLLOWING LINES TO THE PACKAGE::ALGORITHM
            
            hyper_params <- hyperParams(optim_method = m)

            NNreg      <- tryCatch(
                            NNtrain(x = x, y = y, hidden_neur = neur, optim_method = m),
                            error = function(y) {lm(y ~ 0, data = Zxy)}
                          )     
            y_pred     <- tryCatch(
                            ym0 + ysd0 * AMORE::sim.MLPnet(NNreg$net, x),
                            error = ym0
                          )     
            ####
            Ypred[[i]] <- y_pred
            Rmse[i]    <- funRMSE(y_pred, y0)
            Mae[i]     <- funMAE(y_pred, y0)
            timer$stop(event, RMSE = Rmse[i], MAE = Mae[i], params = hyper_params$params, printmsg = FALSE)
        }
        best <- which(Rmse == min(Rmse, na.rm = TRUE))[1]
        best ; Rmse[[best]]
        
        ## ================================================
        ## PLOT ALL MODELS AND THE MODEL WITH THE BEST RMSE
        ## par OPTIONS CAN BE IMPROVED FOR A BETTER DISPLAY
        ## ================================================
        op <- par(mfcol = c(1,2))
        plotNN(xory, y0, uni, TF, main = descr)
        for (i in 1:nrep) lipoNN(xory, Ypred[[i]], uni, TF, col = i, lwd = 1)
        
        plotNN(xory, y0, uni, TF, main = descr)
        lipoNN(xory, Ypred[[best]], uni, TF, col = 4, lwd = 4)
        par(op)
    }


## ===========================
## DETACH ZZ - END OF THE LOOP
## ===========================
    detach(ZZ)
}
```


## Results

```{r}
dfr0 <- getTimer(timer) 

dfr  <- data.frame(
    ds_pkg.fun_algo = stringr::str_sub(dfr0[ ,1], 1, -4),
    run     = stringr::str_sub(dfr0[ ,1], -2, -1),
    dfr0[, c("RMSE","MAE")],
    dataset = stringr::str_replace_all(stringr::str_extract(dfr0[, 1], pattern = "^\\w*_"), fixed("_"), ""),
    method = stringr::str_replace_all(stringr::str_extract(dfr0[, 1], pattern = "_\\w*_"), fixed("_"), ""),
    Elapsed = round(dfr0[ ,4], 5),
    params = dfr0$params
)


dfr %>%
    select(-c(dataset, method))
```

```{r}
clearNN(donotremove)
```