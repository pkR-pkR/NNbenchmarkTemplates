---
title: "NNbenchmark all packages"
author: "All members of  GSoc 2019"
output:
    html_document:
        toc: true
        toc_float: true
        df_print: paged
        number_sections: true
---


```{r message=FALSE, warning=FALSE}
library(NNbenchmark)
library(AMORE)
library(ANN2)
library(nnet)

library(stringr)
library(dplyr)
library(kableExtra)
```

## Set Environment
```{r}
options(scipen = 9999)
options("digits.secs" = 2)
timer  <- createTimer(verbose = FALSE)
```

## Datasets to Test

```{r}
NNdataSummary(NNdatasets)
str(NNdatasets)
odir <- "~/Documents/recherche-enseignement/code/R/NNbenchmark-project/NNtempresult/"

```





## generic call

```{r}
funWAE <- function(y_pred, y0, dgts = 4)
{
    y_pred <- as.numeric(y_pred)
    y0     <- as.numeric(y0) 
    res    <- abs(y_pred - y0)
    z      <- max(res, na.rm = TRUE)
    round(z, dgts)
}

NNsummary <- function(pred, obsy, time)
    c(RMSE = NNbenchmark::funRMSE(pred, obsy), MAE= NNbenchmark::funMAE(pred, obsy), 
      WAE= funWAE(pred, obsy), time=time)

train_and_predict_1mth_1data <- function(dset, method, trainFUN, hyperparamFUN, predictFUN, prepareZZ.arg=list(),
                                         summaryFUN, nrep=5, doplot=FALSE, plot.arg=list(col1=1:nrep, lwd1=1, col2=4, lwd2=3),
                                         pkgname, pkgfun, rdafile=FALSE, odir="~/", echo=FALSE, echoreport=1, ...)
{
    method <- method[1]
    if(!is.list(plot.arg) || any(!names(plot.arg) %in% c("col1", "lwd1", "col2", "lwd2")))
        plot.arg <- list(col1=1:nrep, lwd1=1, col2=4, lwd2=3)
    
    plot.arg$col1 <- rep(plot.arg$col1, length.out=nrep)
       
    timer  <- createTimer(verbose = FALSE)
    
    ds     <- NNbenchmark::NNdatasets[[dset]]$ds
    Z      <- NNbenchmark::NNdatasets[[dset]]$Z
    neur   <- NNbenchmark::NNdatasets[[dset]]$neur
    nparNN <- NNbenchmark::NNdatasets[[dset]]$nparNN
    fmlaNN <- NNbenchmark::NNdatasets[[dset]]$fmlaNN
    
    descr <- paste0(ds, "_", pkgname, "::", pkgfun, "_", method)
    if(echo)
        cat("***\t", descr, "***\n")
    if(length(prepareZZ.arg) != 4 || any(!names(prepareZZ.arg) %in% c("xdmv", "ydmv", "zdm", "scale")))
        prepareZZ.arg <- list(xdmv = "d", ydmv = "v", zdm = "d", scale = TRUE)
    ZZ <- do.call("prepareZZ", c(list(Z), prepareZZ.arg))    
    
    if(echo && echoreport > 1)
    {
        cat("prepareZZ\n")
        print(str(ZZ))
    }
    
    Ypred <- list()
    allsummary <- list()
    for(i in 1:nrep)
    {
        timer$start(descr)
        tempfit <- tryCatch(
            do.call(trainFUN, list(ZZ$x, ZZ$y, neur, method,  hyperparamFUN)),
            error = function(y) {lm(y ~ 0, data = ZZ$Zxy)}
                          ) 
        Ypred[[i]] <- tryCatch(
            ZZ$ym0 + ZZ$ysd0 * do.call(predictFUN, list(tempfit, ZZ$x)),
            error = ZZ$ym0
                        )
        timer$stop(descr, RMSE = NA, MAE = NA, params = NA, printmsg = FALSE)
        allsummary[[i]] <- summaryFUN(Ypred[[i]], ZZ$y0, round(getTimer(timer)[ ,4], 5))
        
        if(echo && i %% 5 == 0)
            cat(pkgname, pkgfun, method, "i", i, "summary statistics", allsummary[[i]][1:3], "time", allsummary[[i]]["time"], "\n")
        
    }
    names(Ypred) <- names(allsummary) <- paste0("replicate", 1:nrep)
    Ypred <- simplify2array(Ypred)
    if(dim(Ypred)[2] == 1)
        Ypred <- Ypred[,1,]
    allsummary <- simplify2array(allsummary)
    
    best <- which.min(allsummary["RMSE",])
    
    #outputs to file
    if(rdafile)
    {
        descr <- paste0(ds, "_", pkgname, "_", pkgfun, "_", method)
        myfile <- paste0(odir, descr, ".RData")
        save(Ypred, allsummary, file=myfile)
    }
    #plot
    if(doplot)
    {
        #shorter description
        descr  <- paste0(ds, "_", pkgname, "::", pkgfun, "_", method)
        op <- par(mfcol = c(1,2))
        plotNN(ZZ$xory, ZZ$y0, ZZ$uni, doplot, main = descr)
        for (i in 1:nrep) 
            lipoNN(ZZ$xory, Ypred[,i], ZZ$uni, doplot, col = plot.arg$col1[i], lwd = plot.arg$lwd1)
        
        plotNN(ZZ$xory, ZZ$y0, ZZ$uni, doplot, main = descr)
        lipoNN(ZZ$xory, Ypred[,best], ZZ$uni, doplot, col = plot.arg$col2, lwd = plot.arg$lwd2)
        par(op)
    }
    if(echo)
        cat("\n")
    allsummary[,best]
}

train_and_predict_1data <- function(dset, methodvect, trainFUN, hyperparamFUN, predictFUN, summaryFUN, prepareZZ.arg=list(),
                                    nrep=5, doplot=FALSE, plot.arg=list(),
                                    pkgname="pkg", pkgfun="train", rdafile=FALSE, odir="~/", echo=FALSE)
{
    nbpkg <- length(pkgname)
    #sanity check
    if(nbpkg > 1)
    {
        if(length(pkgfun) != nbpkg )
            stop("wrong pkgfun")
        if(length(trainFUN) != nbpkg  || length(hyperparamFUN) != nbpkg || length(predictFUN) != nbpkg)
            stop("wrong function names among trainFUN, hyperparamFUN, predictFUN")
        if(length(methodvect) != nbpkg || !is.list(methodvect))
            stop("wrong methodvect")
        if(length(prepareZZ.arg) != nbpkg || !is.list(prepareZZ.arg))
            stop("wrong prepareZZ.arg")
    }
    if(any(!sapply(methodvect, is.character)))
        stop("methvect should be a list of vector of characters")
    if(any(!is.character(trainFUN)))
        stop("trainFUN should be a vector of characters")
    if(any(!is.character(hyperparamFUN)))
        stop("hyperparamFUN should be a vector of characters")
    if(any(!is.character(predictFUN)))
        stop("predictFUN should be a vector of characters")
    if(any(!is.character(pkgname)))
        stop("pkgname should be a vector of characters")
    if(any(!is.character(pkgfun)))
        stop("pkgfun should be a vector of characters")
        
    if(nbpkg == 1)
    {
      if(!exists(trainFUN))
        stop(paste(trainFUN, "does not exist"))
      if(!exists(hyperparamFUN))
        stop(paste(hyperparamFUN, "does not exist"))
      if(!exists(predictFUN))
        stop(paste(predictFUN, "does not exist"))
      resallmethod <- sapply(1:length(methodvect), function(i)
        train_and_predict_1mth_1data(dset=dset, method=methodvect[i], trainFUN=trainFUN, hyperparamFUN=hyperparamFUN, 
                                     predictFUN=predictFUN, summaryFUN=summaryFUN, prepareZZ.arg=prepareZZ.arg, nrep=nrep, doplot=doplot,
                                     pkgname=pkgname, pkgfun=pkgfun, rdafile=rdafile, odir=odir, echo=echo))
      
      colnames(resallmethod) <- methodvect
      return(resallmethod)
    }else
    {
      for(j in 1:nbpkg)
      {
        if(!exists(trainFUN[j]))
          stop(paste(trainFUN[j], "does not exist"))
        if(!exists(hyperparamFUN[j]))
          stop(paste(hyperparamFUN[j], "does not exist"))
        if(!exists(predictFUN[j]))
          stop(paste(predictFUN[j], "does not exist"))
      }
      res1pkg <- function(j)
      {
        mymethod <- methodvect[[j]]
        resallmethod <- sapply(1:length(mymethod), function(i)
          train_and_predict_1mth_1data(dset=dset, method=mymethod[i], trainFUN=trainFUN[j], hyperparamFUN=hyperparamFUN[j], 
                                       predictFUN=predictFUN[j], summaryFUN=summaryFUN, prepareZZ.arg=prepareZZ.arg[[j]], 
                                       nrep=nrep, doplot=doplot, pkgname=pkgname[j], pkgfun=pkgfun[j], rdafile=rdafile, 
                                       odir=odir, echo=echo))
        
        colnames(resallmethod) <- paste0(pkgname[j], "::", mymethod)
        resallmethod
      }
      res <- sapply(1:nbpkg, res1pkg)
      resfinal <- res[[1]]
      for(i in 2:nbpkg)
        resfinal <- cbind(resfinal, res[[i]])    
      return(res)
    }
    
}




```




## AMORE Train/predict Functions
```{r}
hyperParams.AMORE <- function(optim_method) {
    
    if (!is.element(optim_method, c("ADAPTgd", "ADAPTgdwm", "BATCHgd", "BATCHgdwm"))) stop("Invalid Parameters.")
    if (optim_method == "ADAPTgd") {iter <- 3500; lr <- 0.01; momentum <- 0; hidden_activation <- "tansig"} 
    if (optim_method == "ADAPTgdwm") {iter <- 4000; lr <- 0.009; momentum <- 0.8; hidden_activation <- "sigmoid"} 
    if (optim_method == "BATCHgd") {iter <- 7500; lr <- 0.01; momentum <- 0; hidden_activation <- "tansig"}
    if (optim_method == "BATCHgdwm") {iter <- 9000; lr <- 0.008; momentum <- 0.7; hidden_activation <- "tansig"}
    
    params <- paste0("method=", optim_method, "_lr=", lr, "_iter=", iter, "_momentum=", momentum, "_hidden_activation=", hidden_activation)
    
    out <- list(iter = iter, lr = lr, params = params, momentum = momentum, hidden_activation = hidden_activation)
    
    return (out)
}


NNtrain.AMORE <- function(x, y, hidden_neur, optim_method, hyperParams, ...) {
    
    hyper_params <- do.call(hyperParams, list(optim_method, ...))
    
    iter <- hyper_params$iter
    lr <- hyper_params$lr
    momentum <- hyper_params$momentum
    hidden_activation <- hyper_params$hidden_activation
    
    net_structure <- AMORE::newff(n.neurons = c(ncol(x), hidden_neur, 1), 
                                  learning.rate.global = lr, 
                                  error.criterium = "LMS", 
                                  hidden.layer = hidden_activation, 
                                  method = optim_method,
                                  momentum.global = momentum)
    
    NNreg <- AMORE::train(net = net_structure, 
                          P = x, T = y, 
                          error.criterium = "LMS", 
                          report = FALSE, 
                          n.shows = iter, 
                          show.step = 1)
    
    return (NNreg)
}

NNpredict.AMORE <- function(object, x)
    AMORE::sim.MLPnet(object$net, x)    


AMORE.method <- c("ADAPTgd", "ADAPTgdwm", "BATCHgd", "BATCHgdwm")
AMORE.prepareZZ <- list(xdmv = "d", ydmv = "v", zdm = "d", scale = TRUE)

if(FALSE)
res <- train_and_predict_1data(1, AMORE.method, "NNtrain.AMORE", "hyperParams.AMORE", "NNpredict.AMORE", 
                               NNsummary, AMORE.prepareZZ, nrep=5, echo=TRUE, doplot=FALSE,
                               pkgname="AMORE", pkgfun="train", rdafile=TRUE, odir=odir)

```

## ann2 Train/predict Functions
```{r}
ANN2.method <- c("sgd", "rmsprop")
hyperParams.ANN2 <- function(optim_method) {
    
    if (!is.element(optim_method, c("sgd", "adam", "rmsprop"))) stop("Invalid Parameters.")
    if (optim_method == "sgd") { iter <- 4000; lr <- 0.001} 
    if (optim_method == "adam") { iter <- 3000; lr <- 0.007} 
    if (optim_method == "rmsprop") { iter <- 3000; lr <- 0.005} 
    
    params <- paste0("method=", optim_method, "_", "lr=", lr, "_", "iter=", iter)
    
    out <- list(iter = iter, lr = lr, params = params)
    
    return (out)
}
NNtrain.ANN2 <- function(x, y, hidden_neur, optim_method, hyperParams, ...){
    
    hyper_params <- do.call(hyperParams, list(optim_method, ...))
    
    iter <- hyper_params$iter
    lr <- hyper_params$lr
    
    NNreg <- ANN2::neuralnetwork(X = x, y = y, 
                           val.prop = 0, 
                           standardize = FALSE, 
                           hidden.layers = c(hidden_neur), 
                           regression = TRUE,
                           loss.type = "squared",
                           n.epochs = iter,
                           optim.type = optim_method,
                           learn.rates = lr,
                           verbose = FALSE,
                           random.seed = as.integer(runif(1)*10000000))
    
    return (NNreg)
}
NNpredict.ANN2 <- function(object, x)
    predict(object, x)$predictions    
ANN2.prepareZZ <- list(xdmv = "d", ydmv = "v", zdm = "d", scale = TRUE)

if(FALSE)
res <- train_and_predict_1data(1, ANN2.method, "NNtrain.ANN2", "hyperParams.ANN2", "NNpredict.ANN2", 
                               NNsummary, ANN2.prepareZZ, nrep=2, echo=TRUE, doplot=FALSE,
                               pkgname="ANN2", pkgfun="neuralnetwork", rdafile=TRUE, odir=odir)

```



## nnet Train/predict Functions
```{r}
nnet.method <- "none"
hyperParams.nnet <- function(...) {
    return (list(iter=150, trace=FALSE))
}
NNtrain.nnet <- function(x, y, hidden_neur, method, hyperParams, ...) {
    
    hyper_params <- do.call(hyperParams, list(...))
    
    nnet::nnet(x, y, size = hidden_neur, linout = TRUE, maxit = hyper_params$iter, trace=hyper_params$trace)
}
NNpredict.nnet <- function(object, x)
    predict(object, newdata=x)
nnet.prepareZZ <- list(xdmv = "d", ydmv = "v", zdm = "d", scale = TRUE)

if(FALSE)
res <- train_and_predict_1data(1, nnet.method, "NNtrain.nnet", "hyperParams.nnet", "NNpredict.nnet", 
                               NNsummary, nnet.prepareZZ, nrep=5, echo=TRUE, doplot=FALSE,
                               pkgname="nnet", pkgfun="nnet", rdafile=TRUE, odir=odir)

    
```


## all packages
```{r}
methodlist <- list(AMORE.method, ANN2.method, nnet.method)
pkgvect <- c("AMORE", "ANN2", "nnet")
funvect <- c("train", "neuralnetwork", "nnet")
trainvect <- paste("NNtrain", pkgvect, sep=".")
hypervect <- paste("hyperParams", pkgvect, sep=".")
predvect <- paste("NNpredict", pkgvect, sep=".")

preparelist <- list(AMORE.prepareZZ, ANN2.prepareZZ, nnet.prepareZZ)

resall <- train_and_predict_1data(1, methodlist, trainvect, hypervect, predvect,  
                               NNsummary, preparelist, 
                               nrep=2, echo=TRUE, doplot=FALSE,
                               pkgname=pkgvect, pkgfun=funvect, rdafile=TRUE, odir=odir)

```






Old code
```{r, eval=FALSE}
f <- function(i)
    train_and_predict_1data(i, method, "NNtrain.AMORE", hyperParams.AMORE, "NNpredict.AMORE")

library(parallel)

cl <- parallel::makeCluster(2)
print(showConnections())
#put global environment and load packages
parallel::clusterEvalQ(cl, library(NNbenchmark))
parallel::clusterExport(cl, "NNdatasets")
parallel::clusterExport(cl, ls(1))
res <- try( t(parallel::parLapply(cl, 1:2, f)) )
parallel::stopCluster(cl)
```

